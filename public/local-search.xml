<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>32个js问题</title>
    <link href="/2020/09/22/32%E4%B8%AAjs%E9%97%AE%E9%A2%98/"/>
    <url>/2020/09/22/32%E4%B8%AAjs%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>01.数组扁平化<br>数组扁平化是指将一个多维数组变为一个一维数组<br>const arr = [1, [2, [3, [4, 5]]], 6];<br>// =&gt; [1, 2, 3, 4, 5, 6]</p><p>方法一：使用flat()<br>const res1 = arr.flat(Infinity);</p><p>方法二：利用正则<br>const res2 = JSON.stringify(arr).replace(/[|]/g, ‘’).split(‘,’);</p><p>但数据类型都会变为字符串<br>方法三：正则改良版本<br>const res3 = JSON.parse(‘[‘ + JSON.stringify(arr).replace(/[|]/g, ‘’) + ‘]’);</p><p>方法四：使用reduce<br>const flatten = arr =&gt; {<br>  return arr.reduce((pre, cur) =&gt; {<br>    return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);<br>  }, [])<br>}<br>const res4 = flatten(arr);</p><p>方法五：函数递归<br>const res5 = [];<br>const fn = arr =&gt; {<br>  for (let i = 0; i &lt; arr.length; i++) {<br>    if (Array.isArray(arr[i])) {<br>      fn(arr[i]);<br>    } else {<br>      res5.push(arr[i]);<br>    }<br>  }<br>}<br>fn(arr);</p><p>02.数组去重<br>const arr = [1, 1, ‘1’, 17, true, true, false, false, ‘true’, ‘a’, {}, {}];<br>// =&gt; [1, ‘1’, 17, true, false, ‘true’, ‘a’, {}, {}]</p><p>方法一：利用Set<br>const res1 = Array.from(new Set(arr));</p><p>方法二：两层for循环+splice<br>const unique1 = arr =&gt; {<br>  let len = arr.length;<br>  for (let i = 0; i &lt; len; i++) {<br>    for (let j = i + 1; j &lt; len; j++) {<br>      if (arr[i] === arr[j]) {<br>        arr.splice(j, 1);<br>        // 每删除一个树，j–保证j的值经过自加后不变。同时，len–，减少循环次数提升性能<br>        len–;<br>        j–;<br>      }<br>    }<br>  }<br>  return arr;<br>}</p><p>方法三：利用indexOf<br>const unique2 = arr =&gt; {<br>  const res = [];<br>  for (let i = 0; i &lt; arr.length; i++) {<br>    if (res.indexOf(arr[i]) === -1) res.push(arr[i]);<br>  }<br>  return res;<br>}</p><p>当然也可以用include、filter，思路大同小异。<br>方法四：利用include<br>const unique3 = arr =&gt; {<br>  const res = [];<br>  for (let i = 0; i &lt; arr.length; i++) {<br>    if (!res.includes(arr[i])) res.push(arr[i]);<br>  }<br>  return res;<br>}</p><p>方法五：利用filter<br>const unique4 = arr =&gt; {<br>  return arr.filter((item, index) =&gt; {<br>    return arr.indexOf(item) === index;<br>  });<br>}</p><p>方法六：利用Map<br>const unique5 = arr =&gt; {<br>  const map = new Map();<br>  const res = [];<br>  for (let i = 0; i &lt; arr.length; i++) {<br>    if (!map.has(arr[i])) {<br>      map.set(arr[i], true)<br>      res.push(arr[i]);<br>    }<br>  }<br>  return res;<br>}</p><p>03.类数组转化为数组<br>类数组是具有length属性，但不具有数组原型上的方法。常见的类数组有arguments、DOM操作方法返回的结果。<br>方法一：Array.from<br>Array.from(document.querySelectorAll(‘div’))</p><p>方法二：Array.prototype.slice.call()<br>Array.prototype.slice.call(document.querySelectorAll(‘div’))</p><p>方法三：扩展运算符<br>[…document.querySelectorAll(‘div’)]</p><p>方法四：利用concat<br>Array.prototype.concat.apply([], document.querySelectorAll(‘div’));</p><p>04.Array.prototype.filter()</p><p>Array.prototype.filter = function(callback, thisArg) {<br>  if (this == undefined) {<br>    throw new TypeError(‘this is null or not undefined’);<br>  }<br>  if (typeof callback !== ‘function’) {<br>    throw new TypeError(callback + ‘is not a function’);<br>  }<br>  const res = [];<br>  // 让O成为回调函数的对象传递（强制转换对象）<br>  const O = Object(this);<br>  // &gt;&gt;&gt;0 保证len为number，且为正整数<br>  const len = O.length &gt;&gt;&gt; 0;<br>  for (let i = 0; i &lt; len; i++) {<br>    // 检查i是否在O的属性（会检查原型链）<br>    if (i in O) {<br>      // 回调函数调用传参<br>      if (callback.call(thisArg, O[i], i, O)) {<br>        res.push(O[i]);<br>      }<br>    }<br>  }<br>  return res;<br>}</p><p>对于&gt;&gt;&gt;0有疑问的：解释&gt;&gt;&gt;0的作用<br>05.Array.prototype.map()</p><p>Array.prototype.map = function(callback, thisArg) {<br>  if (this == undefined) {<br>    throw new TypeError(‘this is null or not defined’);<br>  }<br>  if (typeof callback !== ‘function’) {<br>    throw new TypeError(callback + ‘ is not a function’);<br>  }<br>  const res = [];<br>  // 同理<br>  const O = Object(this);<br>  const len = O.length &gt;&gt;&gt; 0;<br>  for (let i = 0; i &lt; len; i++) {<br>    if (i in O) {<br>      // 调用回调函数并传入新数组<br>      res[i] = callback.call(thisArg, O[i], i, this);<br>    }<br>  }<br>  return res;<br>}</p><p>06.Array.prototype.forEach()</p><p>forEach跟map类似，唯一不同的是forEach是没有返回值的。<br>Array.prototype.forEach = function(callback, thisArg) {<br>  if (this == null) {<br>    throw new TypeError(‘this is null or not defined’);<br>  }<br>  if (typeof callback !== “function”) {<br>    throw new TypeError(callback + ‘ is not a function’);<br>  }<br>  const O = Object(this);<br>  const len = O.length &gt;&gt;&gt; 0;<br>  let k = 0;<br>  while (k &lt; len) {<br>    if (k in O) {<br>      callback.call(thisArg, O[k], k, O);<br>    }<br>    k++;<br>  }<br>}</p><p>07.Array.prototype.reduce()</p><p>Array.prototype.reduce = function(callback, initialValue) {<br>  if (this == undefined) {<br>    throw new TypeError(‘this is null or not defined’);<br>  }<br>  if (typeof callback !== ‘function’) {<br>    throw new TypeError(callbackfn + ‘ is not a function’);<br>  }<br>  const O = Object(this);<br>  const len = this.length &gt;&gt;&gt; 0;<br>  let accumulator = initialValue;<br>  let k = 0;<br>  // 如果第二个参数为undefined的情况下<br>  // 则数组的第一个有效值作为累加器的初始值<br>  if (accumulator === undefined) {<br>    while (k &lt; len &amp;&amp; !(k in O)) {<br>      k++;<br>    }<br>    // 如果超出数组界限还没有找到累加器的初始值，则TypeError<br>    if (k &gt;= len) {<br>      throw new TypeError(‘Reduce of empty array with no initial value’);<br>    }<br>    accumulator = O[k++];<br>  }<br>  while (k &lt; len) {<br>    if (k in O) {<br>      accumulator = callback.call(undefined, accumulator, O[k], k, O);<br>    }<br>    k++;<br>  }<br>  return accumulator;<br>}</p><p>08.Function.prototype.apply()<br>第一个参数是绑定的this，默认为window，第二个参数是数组或类数组<br>Function.prototype.apply = function(context = window, args) {<br>  if (typeof this !== ‘function’) {<br>    throw new TypeError(‘Type Error’);<br>  }<br>  const fn = Symbol(‘fn’);<br>  context[fn] = this;</p><p>  const res = context<a href="...args">fn</a>;<br>  delete context[fn];<br>  return res;<br>}</p><p>09.Function.prototype.call<br>于call唯一不同的是，call()方法接受的是一个参数列表<br>Function.prototype.call = function(context = window, …args) {<br>  if (typeof this !== ‘function’) {<br>    throw new TypeError(‘Type Error’);<br>  }<br>  const fn = Symbol(‘fn’);<br>  context[fn] = this;</p><p>  const res = this<a href="...args">fn</a>;<br>  delete this.fn;<br>  return res;<br>}</p><p>10.Function.prototype.bind<br>Function.prototype.bind = function(context, …args) {<br>  if (typeof this !== ‘function’) {<br>    throw new Error(“Type Error”);<br>  }<br>  // 保存this的值<br>  var self = this;</p><p>  return function F() {<br>    // 考虑new的情况<br>    if(this instanceof F) {<br>      return new self(…args, …arguments)<br>    }<br>    return self.apply(context, […args, …arguments])<br>  }<br>}</p><p>11.debounce（防抖）<br>触发高频时间后n秒内函数只会执行一次,如果n秒内高频时间再次触发,则重新计算时间。<br>const debounce = (fn, time) =&gt; {<br>  let timeout = null;<br>  return function() {<br>    clearTimeout(timeout)<br>    timeout = setTimeout(() =&gt; {<br>      fn.apply(this, arguments);<br>    }, time);<br>  }<br>};</p><p>防抖常应用于用户进行搜索输入节约请求资源，window触发resize事件时进行防抖只触发一次。<br>12.throttle（节流）<br>高频时间触发,但n秒内只会执行一次,所以节流会稀释函数的执行频率。<br>const throttle = (fn, time) =&gt; {<br>  let flag = true;<br>  return function() {<br>    if (!flag) return;<br>    flag = false;<br>    setTimeout(() =&gt; {<br>      fn.apply(this, arguments);<br>      flag = true;<br>    }, time);<br>  }<br>}</p><p>节流常应用于鼠标不断点击触发、监听滚动事件。<br>13.函数珂里化</p><p>指的是将一个接受多个参数的函数 变为 接受一个参数返回一个函数的固定形式，这样便于再次调用，例如f(1)(2)</p><p>经典面试题：实现add(1)(2)(3)(4)=10; 、 add(1)(1,2,3)(2)=9;<br>function add() {<br>  const _args = […arguments];<br>  function fn() {<br>    _args.push(…arguments);<br>    return fn;<br>  }<br>  fn.toString = function() {<br>    return _args.reduce((sum, cur) =&gt; sum + cur);<br>  }<br>  return fn;<br>}</p><p>14.模拟new操作<br>3个步骤：</p><p>以ctor.prototype为原型创建一个对象。<br>执行构造函数并将this绑定到新创建的对象上。<br>判断构造函数执行返回的结果是否是引用数据类型，若是则返回构造函数执行的结果，否则返回创建的对象。</p><p>function newOperator(ctor, …args) {<br>  if (typeof ctor !== ‘function’) {<br>    throw new TypeError(‘Type Error’);<br>  }<br>  const obj = Object.create(ctor.prototype);<br>  const res = ctor.apply(obj, args);</p><p>  const isObject = typeof res === ‘object’ &amp;&amp; res !== null;<br>  const isFunction = typeof res === ‘function’;<br>  return isObject || isFunction ? res : obj;<br>}</p><p>15.instanceof<br>instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。<br>const myInstanceof = (left, right) =&gt; {<br>  // 基本数据类型都返回false<br>  if (typeof left !== ‘object’ || left === null) return false;<br>  let proto = Object.getPrototypeOf(left);<br>  while (true) {<br>    if (proto === null) return false;<br>    if (proto === right.prototype) return true;<br>    proto = Object.getPrototypeOf(proto);<br>  }<br>}</p><p>16.原型继承<br>这里只写寄生组合继承了，中间还有几个演变过来的继承但都有一些缺陷<br>function Parent5) {<br>  this.name = ‘parent’;<br>}<br>function Child() {<br>  Parent.call(this);<br>  this.type = ‘children’;<br>}<br>Child.prototype = Object.create(Parent.prototype);<br>Child.prototype.constructor = Child;</p><p>17.Object.is<br>Object.is解决的主要是这两个问题：<br>+0 === -0  // true<br>NaN === NaN // false</p><p>const is= (x, y) =&gt; {<br>  if (x === y) {<br>    // +0和-0应该不相等<br>    return x !== 0 || y !== 0 || 1/x === 1/y;<br>  } else {<br>    return x !== x &amp;&amp; y !== y;<br>  }<br>}</p><p>18.Object.assign<br>Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象（请注意这个操作是浅拷贝）<br>Object.defineProperty(Object, ‘assign’, {<br>  value: function(target, …args) {<br>    if (target == null) {<br>      return new TypeError(‘Cannot convert undefined or null to object’);<br>    }</p><pre><code>// 目标对象需要统一是引用数据类型，若不是会自动转换const to = Object(target);for (let i = 0; i &lt; args.length; i++) &#123;  // 每一个源对象  const nextSource = args[i];  if (nextSource !== null) &#123;    // 使用for...in和hasOwnProperty双重判断，确保只拿到本身的属性、方法（不包含继承的）    for (const nextKey in nextSource) &#123;      if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123;        to[nextKey] = nextSource[nextKey];      &#125;    &#125;  &#125;&#125;return to;</code></pre><p>  },<br>  // 不可枚举<br>  enumerable: false,<br>  writable: true,<br>  configurable: true,<br>})</p><p>19.深拷贝<br>递归的完整版本（考虑到了Symbol属性）：<br>const cloneDeep1 = (target, hash = new WeakMap()) =&gt; {<br>  // 对于传入参数处理<br>  if (typeof target !== ‘object’ || target === null) {<br>    return target;<br>  }<br>  // 哈希表中存在直接返回<br>  if (hash.has(target)) return hash.get(target);</p><p>  const cloneTarget = Array.isArray(target) ? [] : {};<br>  hash.set(target, cloneTarget);</p><p>  // 针对Symbol属性<br>  const symKeys = Object.getOwnPropertySymbols(target);<br>  if (symKeys.length) {<br>    symKeys.forEach(symKey =&gt; {<br>      if (typeof target[symKey] === ‘object’ &amp;&amp; target[symKey] !== null) {<br>        cloneTarget[symKey] = cloneDeep1(target[symKey]);<br>      } else {<br>        cloneTarget[symKey] = target[symKey];<br>      }<br>    })<br>  }</p><p>  for (const i in target) {<br>    if (Object.prototype.hasOwnProperty.call(target, i)) {<br>      cloneTarget[i] =<br>        typeof target[i] === ‘object’ &amp;&amp; target[i] !== null<br>        ? cloneDeep1(target[i], hash)<br>        : target[i];<br>    }<br>  }<br>  return cloneTarget;<br>}</p><p>20.Promise<br>实现思路：Promise源码实现<br>const PENDING = ‘PENDING’;      // 进行中<br>const FULFILLED = ‘FULFILLED’;  // 已成功<br>const REJECTED = ‘REJECTED’;    // 已失败</p><p>class Promise {<br>  constructor(exector) {<br>    // 初始化状态<br>    this.status = PENDING;<br>    // 将成功、失败结果放在this上，便于then、catch访问<br>    this.value = undefined;<br>    this.reason = undefined;<br>    // 成功态回调函数队列<br>    this.onFulfilledCallbacks = [];<br>    // 失败态回调函数队列<br>    this.onRejectedCallbacks = [];</p><pre><code>const resolve = value =&gt; &#123;  // 只有进行中状态才能更改状态  if (this.status === PENDING) &#123;    this.status = FULFILLED;    this.value = value;    // 成功态函数依次执行    this.onFulfilledCallbacks.forEach(fn =&gt; fn(this.value));  &#125;&#125;const reject = reason =&gt; &#123;  // 只有进行中状态才能更改状态  if (this.status === PENDING) &#123;    this.status = REJECTED;    this.reason = reason;    // 失败态函数依次执行    this.onRejectedCallbacks.forEach(fn =&gt; fn(this.reason))  &#125;&#125;try &#123;  // 立即执行executor  // 把内部的resolve和reject传入executor，用户可调用resolve和reject  exector(resolve, reject);&#125; catch(e) &#123;  // executor执行出错，将错误内容reject抛出去  reject(e);&#125;</code></pre><p>  }<br>  then(onFulfilled, onRejected) {<br>    onFulfilled = typeof onFulfilled === ‘function’ ? onFulfilled : value =&gt; value;<br>    onRejected = typeof onRejected === ‘function’? onRejected:<br>      reason =&gt; { throw new Error(reason instanceof Error ? reason.message:reason) }<br>    // 保存this<br>    const self = this;<br>    return new Promise((resolve, reject) =&gt; {<br>      if (self.status === PENDING) {<br>        self.onFulfilledCallbacks.push(() =&gt; {<br>          // try捕获错误<br>          try {<br>            // 模拟微任务<br>            setTimeout(() =&gt; {<br>              const result = onFulfilled(self.value);<br>              // 分两种情况：<br>              // 1. 回调函数返回值是Promise，执行then操作<br>              // 2. 如果不是Promise，调用新Promise的resolve函数<br>              result instanceof Promise ? result.then(resolve, reject) : resolve(result);<br>            })<br>          } catch(e) {<br>            reject(e);<br>          }<br>        });<br>        self.onRejectedCallbacks.push(() =&gt; {<br>          // 以下同理<br>          try {<br>            setTimeout(() =&gt; {<br>              const result = onRejected(self.reason);<br>              // 不同点：此时是reject<br>              result instanceof Promise ? result.then(resolve, reject) : reject(result);<br>            })<br>          } catch(e) {<br>            reject(e);<br>          }<br>        })<br>      } else if (self.status === FULFILLED) {<br>        try {<br>          setTimeout(() =&gt; {<br>            const result = onFulfilled(self.value);<br>            result instanceof Promise ? result.then(resolve, reject) : resolve(result);<br>          });<br>        } catch(e) {<br>          reject(e);<br>        }<br>      } else if (self.status === REJECTED){<br>        try {<br>          setTimeout(() =&gt; {<br>            const result = onRejected(self.reason);<br>            result instanceof Promise ? result.then(resolve, reject) : reject(result);<br>          })<br>        } catch(e) {<br>          reject(e);<br>        }<br>      }<br>    });<br>  }<br>  catch(onRejected) {<br>    return this.then(null, onRejected);<br>  }<br>  static resolve(value) {<br>    if (value instanceof Promise) {<br>      // 如果是Promise实例，直接返回<br>      return value;<br>    } else {<br>      // 如果不是Promise实例，返回一个新的Promise对象，状态为FULFILLED<br>      return new Promise((resolve, reject) =&gt; resolve(value));<br>    }<br>  }<br>  static reject(reason) {<br>    return new Promise((resolve, reject) =&gt; {<br>      reject(reason);<br>    })<br>  }<br>}</p><p>21.Promise.all<br>Promise.all是支持链式调用的，本质上就是返回了一个Promise实例，通过resolve和reject来改变实例状态。<br>Promise.myAll = function(promiseArr) {<br>  return new Promise((resolve, reject) =&gt; {<br>    const ans = [];<br>    let index = 0;<br>    for (let i = 0; i &lt; promiseArr.length; i++) {<br>      promiseArr[i]<br>      .then(res =&gt; {<br>        ans[i] = res;<br>        index++;<br>        if (index === promiseArr.length) {<br>          resolve(ans);<br>        }<br>      })<br>      .catch(err =&gt; reject(err));<br>    }<br>  })<br>}</p><p>22.Promise.race<br>Promise.race = function(promiseArr) {<br>  return new Promise((resolve, reject) =&gt; {<br>    promiseArr.forEach(p =&gt; {<br>      // 如果不是Promise实例需要转化为Promise实例<br>      Promise.resolve(p).then(<br>        val =&gt; resolve(val),<br>        err =&gt; reject(err),<br>      )<br>    })<br>  })<br>}</p><p>23.Promise并行限制<br>就是实现有并行限制的Promise调度器问题。<br>详细实现思路：某条高频面试原题：实现有并行限制的Promise调度器<br>class Scheduler {<br>  constructor() {<br>    this.queue = [];<br>    this.maxCount = 2;<br>    this.runCounts = 0;<br>  }<br>  add(promiseCreator) {<br>    this.queue.push(promiseCreator);<br>  }<br>  taskStart() {<br>    for (let i = 0; i &lt; this.maxCount; i++) {<br>      this.request();<br>    }<br>  }<br>  request() {<br>    if (!this.queue || !this.queue.length || this.runCounts &gt;= this.maxCount) {<br>      return;<br>    }<br>    this.runCounts++;</p><pre><code>this.queue.shift()().then(() =&gt; &#123;  this.runCounts--;  this.request();&#125;);</code></pre><p>  }<br>}</p><p>const timeout = time =&gt; new Promise(resolve =&gt; {<br>  setTimeout(resolve, time);<br>})</p><p>const scheduler = new Scheduler();</p><p>const addTask = (time,order) =&gt; {<br>  scheduler.add(() =&gt; timeout(time).then(()=&gt;console.log(order)))<br>}</p><p>addTask(1000, ‘1’);<br>addTask(500, ‘2’);<br>addTask(300, ‘3’);<br>addTask(400, ‘4’);<br>scheduler.taskStart()<br>// 2<br>// 3<br>// 1<br>// 4</p><p>24.JSONP<br>script标签不遵循同源协议，可以用来进行跨域请求，优点就是兼容性好但仅限于GET请求<br>const jsonp = ({ url, params, callbackName }) =&gt; {<br>  const generateUrl = () =&gt; {<br>    let dataSrc = ‘’;<br>    for (let key in params) {<br>      if (Object.prototype.hasOwnProperty.call(params, key)) {<br>        dataSrc += <code>$&#123;key&#125;=$&#123;params[key]&#125;&amp;</code>;<br>      }<br>    }<br>    dataSrc += <code>callback=$&#123;callbackName&#125;</code>;<br>    return <code>$&#123;url&#125;?$&#123;dataSrc&#125;</code>;<br>  }<br>  return new Promise((resolve, reject) =&gt; {<br>    const scriptEle = document.createElement(‘script’);<br>    scriptEle.src = generateUrl();<br>    document.body.appendChild(scriptEle);<br>    window[callbackName] = data =&gt; {<br>      resolve(data);<br>      document.removeChild(scriptEle);<br>    }<br>  })<br>}</p><p>25.AJAX<br>const getJSON = function(url) {<br>  return new Promise((resolve, reject) =&gt; {<br>    const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(‘Mscrosoft.XMLHttp’);<br>    xhr.open(‘GET’, url, false);<br>    xhr.setRequestHeader(‘Accept’, ‘application/json’);<br>    xhr.onreadystatechange = function() {<br>      if (xhr.readyState !== 4) return;<br>      if (xhr.status === 200 || xhr.status === 304) {<br>        resolve(xhr.responseText);<br>      } else {<br>        reject(new Error(xhr.responseText));<br>      }<br>    }<br>    xhr.send();<br>  })<br>}</p><p>26.event模块<br>实现node中回调函数的机制，node中回调函数其实是内部使用了观察者模式。</p><p>观察者模式：定义了对象间一种一对多的依赖关系，当目标对象Subject发生改变时，所有依赖它的对象Observer都会得到通知。</p><p>function EventEmitter() {<br>  this.events = new Map();<br>}</p><p>// 需要实现的一些方法：<br>// addListener、removeListener、once、removeAllListeners、emit</p><p>// 模拟实现addlistener方法<br>const wrapCallback = (fn, once = false) =&gt; ({ callback: fn, once });<br>EventEmitter.prototype.addListener = function(type, fn, once = false) {<br>  const hanlder = this.events.get(type);<br>  if (!hanlder) {<br>    // 没有type绑定事件<br>    this.events.set(type, wrapCallback(fn, once));<br>  } else if (hanlder &amp;&amp; typeof hanlder.callback === ‘function’) {<br>    // 目前type事件只有一个回调<br>    this.events.set(type, [hanlder, wrapCallback(fn, once)]);<br>  } else {<br>    // 目前type事件数&gt;=2<br>    hanlder.push(wrapCallback(fn, once));<br>  }<br>}<br>// 模拟实现removeListener<br>EventEmitter.prototype.removeListener = function(type, listener) {<br>  const hanlder = this.events.get(type);<br>  if (!hanlder) return;<br>  if (!Array.isArray(this.events)) {<br>    if (hanlder.callback === listener.callback) this.events.delete(type);<br>    else return;<br>  }<br>  for (let i = 0; i &lt; hanlder.length; i++) {<br>    const item = hanlder[i];<br>    if (item.callback === listener.callback) {<br>      hanlder.splice(i, 1);<br>      i–;<br>      if (hanlder.length === 1) {<br>        this.events.set(type, hanlder[0]);<br>      }<br>    }<br>  }<br>}<br>// 模拟实现once方法<br>EventEmitter.prototype.once = function(type, listener) {<br>  this.addListener(type, listener, true);<br>}<br>// 模拟实现emit方法<br>EventEmitter.prototype.emit = function(type, …args) {<br>  const hanlder = this.events.get(type);<br>  if (!hanlder) return;<br>  if (Array.isArray(hanlder)) {<br>    hanlder.forEach(item =&gt; {<br>      item.callback.apply(this, args);<br>      if (item.once) {<br>        this.removeListener(type, item);<br>      }<br>    })<br>  } else {<br>    hanlder.callback.apply(this, args);<br>    if (hanlder.once) {<br>      this.events.delete(type);<br>    }<br>  }<br>  return true;<br>}<br>EventEmitter.prototype.removeAllListeners = function(type) {<br>  const hanlder = this.events.get(type);<br>  if (!hanlder) return;<br>  this.events.delete(type);<br>}</p><p>27.图片懒加载<br>可以给img标签统一自定义属性data-src=’default.png’，当检测到图片出现在窗口之后再补充src属性，此时才会进行图片资源加载。<br>function lazyload() {<br>  const imgs = document.getElementsByTagName(‘img’);<br>  const len = imgs.length;<br>  // 视口的高度<br>  const viewHeight = document.documentElement.clientHeight;<br>  // 滚动条高度<br>  const scrollHeight = document.documentElement.scrollTop || document.body.scrollTop;<br>  for (let i = 0; i &lt; len; i++) {<br>    const offsetHeight = imgs[i].offsetTop;<br>    if (offsetHeight &lt; viewHeight + scrollHeight) {<br>      const src = imgs[i].dataset.src;<br>      imgs[i].src = src;<br>    }<br>  }<br>}</p><p>// 可以使用节流优化一下<br>window.addEventListener(‘scroll’, lazyload);</p><p>28.滚动加载<br>原理就是监听页面滚动事件，分析clientHeight、scrollTop、scrollHeight三者的属性关系。<br>window.addEventListener(‘scroll’, function() {<br>  const clientHeight = document.documentElement.clientHeight;<br>  const scrollTop = document.documentElement.scrollTop;<br>  const scrollHeight = document.documentElement.scrollHeight;<br>  if (clientHeight + scrollTop &gt;= scrollHeight) {<br>    // 检测到滚动至页面底部，进行后续操作<br>    // …<br>  }<br>}, false);</p><p>一个Demo：页面滚动加载的Demo<br>29.渲染几万条数据不卡住页面<br>渲染大数据时，合理使用createDocumentFragment和requestAnimationFrame，将操作切分为一小段一小段执行。<br>setTimeout(() =&gt; {<br>  // 插入十万条数据<br>  const total = 100000;<br>  // 一次插入的数据<br>  const once = 20;<br>  // 插入数据需要的次数<br>  const loopCount = Math.ceil(total / once);<br>  let countOfRender = 0;<br>  const ul = document.querySelector(‘ul’);<br>  // 添加数据的方法<br>  function add() {<br>    const fragment = document.createDocumentFragment();<br>    for(let i = 0; i &lt; once; i++) {<br>      const li = document.createElement(‘li’);<br>      li.innerText = Math.floor(Math.random() * total);<br>      fragment.appendChild(li);<br>    }<br>    ul.appendChild(fragment);<br>    countOfRender += 1;<br>    loop();<br>  }<br>  function loop() {<br>    if(countOfRender &lt; loopCount) {<br>      window.requestAnimationFrame(add);<br>    }<br>  }<br>  loop();<br>}, 0)</p><p>30.打印出当前网页使用了多少种HTML元素<br>一行代码可以解决：<br>const fn = () =&gt; {<br>  return […new Set([…document.querySelectorAll(‘*’)].map(el =&gt; el.tagName))].length;<br>}</p><p>值得注意的是：DOM操作返回的是类数组，需要转换为数组之后才可以调用数组的方法。<br>31.将VirtualDom转化为真实DOM结构<br>这是当前SPA应用的核心概念之一<br>// vnode结构：<br>// {<br>//   tag,<br>//   attrs,<br>//   children,<br>// }</p><p>//Virtual DOM =&gt; DOM<br>function render(vnode, container) {<br>  container.appendChild(_render(vnode));<br>}<br>function _render(vnode) {<br>  // 如果是数字类型转化为字符串<br>  if (typeof vnode === ‘number’) {<br>    vnode = String(vnode);<br>  }<br>  // 字符串类型直接就是文本节点<br>  if (typeof vnode === ‘string’) {<br>    return document.createTextNode(vnode);<br>  }<br>  // 普通DOM<br>  const dom = document.createElement(vnode.tag);<br>  if (vnode.attrs) {<br>    // 遍历属性<br>    Object.keys(vnode.attrs).forEach(key =&gt; {<br>      const value = vnode.attrs[key];<br>      dom.setAttribute(key, value);<br>    })<br>  }<br>  // 子数组进行递归操作<br>  vnode.children.forEach(child =&gt; render(child, dom));<br>  return dom;<br>}</p><p>32.字符串解析问题<br>var a = {<br>    b: 123,<br>    c: ‘456’,<br>    e: ‘789’,<br>}<br>var str=<code>a&#123;a.b&#125;aa&#123;a.c&#125;aa &#123;a.d&#125;aaaa</code>;<br>// =&gt; ‘a123aa456aa {a.d}aaaa’</p><p>实现函数使得将str字符串中的{}内的变量替换，如果属性不存在保持原样（比如{a.d}）<br>类似于模版字符串，但有一点出入，实际上原理大差不差<br>const fn1 = (str, obj) =&gt; {<br>    let res = ‘’;<br>    // 标志位，标志前面是否有{<br>    let flag = false;<br>    let start;<br>    for (let i = 0; i &lt; str.length; i++) {<br>        if (str[i] === ‘{‘) {<br>            flag = true;<br>            start = i + 1;<br>            continue;<br>        }<br>        if (!flag) res += str[i];<br>        else {<br>            if (str[i] === ‘}’) {<br>                flag = false;<br>                res += match(str.slice(start, i), obj);<br>            }<br>        }<br>    }<br>    return res;<br>}<br>// 对象匹配操作<br>const match = (str, obj) =&gt; {<br>    const keys = str.split(‘.’).slice(1);<br>    let index = 0;<br>    let o = obj;<br>    while (index &lt; keys.length) {<br>        const key = keys[index];<br>        if (!o[key]) {<br>            return <code>&#123;$&#123;str&#125;&#125;</code>;<br>        } else {<br>            o = o[key];<br>        }<br>        index++;<br>    }<br>    return o;<br>}</p>]]></content>
    
    
    
    <tags>
      
      <tag>program</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>excel常用公式</title>
    <link href="/2020/09/21/excel%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F/"/>
    <url>/2020/09/21/excel%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>1、IF函数条件判断<br>IF函数是最常用的判断类函数之一，能完成非此即彼的判断。<br>如下图，考核得分的标准为9分，要判断B列的考核成绩是否合格。<br>=IF(B4&gt;=9,”合格”,”不合格”)</p><p>IF，相当于普通话的“如果”，常规用法是：<br>IF(判断的条件,符合条件时的结果,不符合条件时的结果)</p><p>2、多条件判断<br>如下图所示，如果部门为生产、岗位为主操 有高温补助。在D列使用公式：<br>=IF(AND(B2=”生产”,C2=”主操”),”有”,”无”)</p><p>AND函数对两个条件判断，如果同时符合，IF函数返回“有”，否则为无。</p><p>3、条件求和<br>如下图所示，使用SUMIF函数计算一班的总成绩：<br>=SUMIF(D2:D5,F2,C2:C5)</p><p>SUMIF用法是：<br>=SUMIF(条件区域,指定的求和条件,求和的区域)<br>用通俗的话描述就是：<br>如果D2:D5区域的班级等于F2单元格的“一班”，就对C2:C5单元格对应的区域求和。</p><p>4、多条件求和<br>如下图所示，要统计部门为生产,并且岗位为主操的补助总额。<br>公式为：<br>=SUMIFS(D2:D9,B2:B9,F2,C2:C9,G2)</p><p>SUMIFS用法是：<br>=SUMIFS(求和的区域，条件区域1,指定的求和条件1,条件区域2,指定的求和条件2,……)</p><p>5、条件计数<br>如下图，要统计指定店铺的业务笔数。也就是统计B列中有多少个指定的店铺名称。<br>=COUNTIF(B2:B12,E3)</p><p>COUNTIF函数统计条件区域中，符合指定条件的单元格个数。常规用法为：<br>=COUNTIF(条件区域,指定条件)</p><p>6、多条件计数<br>要求：统计统计部门为生产,并且岗位为主操的人数<br>公式为：<br>=COUNTIFS(B2:B9,F2,C2:C9,G2)</p><p>COUNTIFS函数统计条件区域中，符合多个指定条件的单元格个数。常规用法为：<br>=COUNTIFS(条件区域1,指定条件1,条件区域2,指定条件2……)</p><p>7、条件查找<br>VLOOKUP函数一直是大众情人般的存在，函数的语法为：<br>VLOOKUP(要找谁,在哪儿找,返回第几列的内容,精确找还是近似找)<br>如下图，要查询F5单元格中的员工姓名是什么职务。<br>=VLOOKUP($F$5,$B$1:$D$10,2,0)</p><p>使用该函数时，需要注意以下几点：<br>1、第4参数一般用0（或FASLE）以精确匹配方式进行查找。<br>2、第3参数中的列号，不能理解为工作表中实际的列号，而是指定返回值在查找范围中的第几列。<br>3、如果查找值与数据区域关键字的数据类型不一致，会返回错误值#N/A。<br>4、查找值必须位于查询区域中的第一列。</p><p>8、多条件查找<br>如下图所示，要求查询部门为生产,并且岗位为部长的姓名。<br>公式为：<br>=LOOKUP(1,0/((B2:B9=F2)*(C2:C9=G2)),A2:A9)</p><p>LOOKUP函数多条件查询写法为：<br>=LOOKUP(1,0/((条件区域1=条件1)*(条件区域2=条件2)),查询区域)</p><p>9、计算文本算式<br>如下图，要计算单元格中的文本算式，先单击第一个要输入公式的单元格，定义名称 ：<br>计算 = EVALUATE(C2)<br>然后在单元格中输入公式：<br>=计算</p><p>10、合并多个单元格内容<br>要连接合并多个单元格中的内容，可以使用&amp;符号完成。如下图，要合并A列的姓名和B列的电话号码，可以使用公式：<br>=A2&amp;B$1&amp;B2</p><p>11、合并带格式的单元格内容<br>合并带有格式的内容时，Excel默认按常规格式进行合并，但是如果是日期、时间或是其他有格式的数值，结果就会让人大失所望了：</p><p>如何才能正确连接出需要的字符串呢？其实很简单，C2公式为：<br>=A2&amp;TEXT(B2,” y年m月d日”)</p><p>首先使用TEXT函数，把B列的日期变成具有特定样式的字符串，然后再与A列的姓名连接，就变成了最终需要的样式。</p><p>12、比较大小写的单词是否相同<br>如果在A1和A2单元格中分别输入大小写的单词，使用以下公式判断时，Excel会默认二者是相同的：<br>=A2=B2</p><p>如需区别大小写，可以使用公式：<br>=EXACT(A2,B2)<br>EXACT函数 区分大小写，但忽略格式上的差异。</p><p>13、提取混合内容中的姓名<br>如下图，要从A列姓名电话中提取出姓名，除了使用高版本的自动填充功能，还可以使用公式完成：<br>=LEFT(A2,LENB(A2)-LEN(A2))</p><p>LENB函数将每个汉字（双字节字符）的字符数按2计数，LEN函数则对所有的字符都按1计数。因此“LENB(A2)-LEN(A2)”返回的结果就是文本字符串中的汉字个数。<br>LEFT函数从文本字符串的第一个字符开始，返回指定个数的字符，最终提取出员工姓名。</p><p>14、根据身份证号码提取出生年月<br>计算公式为：<br>=1*TEXT(MID(B2,7,8),”0-00-00”)</p><p>首先使用MID函数从B2单元格的第7位开始，提取出表示出生年月的8个字符，结果为：<br>“19780215”<br>再使用TEXT函数将字符串转换为日期样式：<br>“1978-02-15”<br>然后通过*1计算，将其转换为真正的日期。最后设置为日期格式即可。</p><p>15、替换部分电话号码<br>如下图所示，要将手机号码的中间四位换成星号，公式为：<br>=SUBSTITUTE(B2,MID(B2,4,4),”****”,1)</p><p>SUBSTITUTE函数的用法是：<br>SUBSTITUTE(要替换的文本,旧文本,新文本,[替换第几个])<br>先使用MID函数取得B列号码中的中间4位，再用“*****”替换掉这部分内容。<br>最后一个参数使用1，表示只替换第一次出现的内容。比如第九行的电话号码是13801010101，最后四位和中间四位相同，如果不指定1，就会全部替换掉了。</p><p>16、屏蔽函数公式返回的错误值<br>在使用函数公式过程中，经常会返回一些诸如#N/A、#NAME?之类的错误值，要屏蔽这些错误值其实很简单，只需在原公式外侧加上一个IFERROR函数就好。<br>IFERROR函数的用法为：<br>=IFERROR(原公式,出现错误时要返回的内容)<br>如果公式正确，就返回原有计算结果，如果公式返回的是错误值，就返回用户指定的显示内容。</p><p>17、四舍五入函数<br>ROUND函数这个想必大家经常用到吧，就是对数值按指定的位数四舍五入。比如：<br>=ROUND(8/9,3)<br>就是将8/9的计算结果四舍五入到三位小数，结果为0.889。</p><p>18、取整的间隔小时数<br>计算两个时间的间隔小时数，不足一小时部分舍去，计算加班时经常会用到，说多了都是泪……<br>=TEXT(B2-B1,”[h]”)</p><p>19、提取日期时间中的日期值<br>要从日期时间数据中提取出日期，可以使用以下公式：<br>=INT(A2)<br>要继续提取时间，只需要做个减法，就欧了：</p><p>20、生成随机数<br>RANDBETWEEN能够在指定范围内生成一组随机数据，对于广大质检、监理、统计人员来说，这的确是一个伟大的函数。<br>函数的用法是：<br>=RANDBETWEEN(数字下限,数字上限)<br>比如以下公式，就是生成60到100之间的随机数：<br>=RANDBETWEEN(60,100)</p>]]></content>
    
    
    
    <tags>
      
      <tag>useful</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3傻瓜式入门</title>
    <link href="/2020/09/20/a/"/>
    <url>/2020/09/20/a/</url>
    
    <content type="html"><![CDATA[<p>可任选一种创建方式<br>我个人还是采用的脚手架<br>升级（即重装）<br>npm install -g @vue/cli # OR yarn global add @vue/cli<br>vue create hello-vue3<br>下面和原来不同的就是多了个选择版本的，选择vue3上手即可</p><h2>一、重点</h2>先以下面官网所列出的显著的为主（后三个先忽略）<h3>1.1. composition API</h3>别不管 Options API 与composition API 比较，我们先直接上手composition API composition API 入口点setup函数创建响应式数据 ref与reactiverefref函数接一个参数返回一个响应式的ref对象直接看栗子<p><xmp><srcript><br>  <div><br>      <br>  </div><br></xmp></template><br><xmp><srcript><br>import { ref } from “vue”;<br>export default {<br>  setup() {<br>    const num = ref(1);<br>    return { num };<br>  },<br>};<br></srcript><br></xmp><br>也即和vue2.x中的这种写法是一样的<br>data(){<br>    return {<br>        num:1<br>    }<br>}</p><p>值得注意的是：ref返回的是一个对象，需要通过它的value属性拿到它的值<br>也即num.value。不过在模板中使用时他会自动解。也就是上面栗子中模板直接使用num，还有一种可自动解的情况先看下面<br>另外现在就可以理解ref是用来把简单类型的数据进行响应式化的<br>reactive<br>ref负责简单数据数据，则reactive就是将引用类型的数据进行响应式化<br>直接看栗子</p><p><xmp><srcript><br>  <div></div><br></xmp></template><br><xmp><srcript><br>import { ref, reactive } from “vue”;<br>export default {<br>  setup() {<br>    const num = ref(1);<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,<br>    });<br>    return { num, obj };<br>  },<br>};<br></srcript><br></xmp></p><p>上面的ref对象自动解套的另一种情况也即在这里它作为reactive函数参数对象的一属性<br>即:<br> const num = ref(1);<br>const obj = reactive({<br>      name: “gxb”,<br>      age: 18,<br>      num<br>    });</p><p>值得注意的是：这里不要随意使用…语法或者解构，否则会丧失响应式性质，最后的工具函数那再写栗子介绍<br>readonly<br>这个函数，参数可以一个响应式或者普通的对象再或者是个ref。返回的是一个只读代理（深层的）<br>栗子<br><img src="1.png"><br>computed 与 watch<br>computed<br>computed是一个函数，它需要传一个getter函数。其返回值是一个不可手动修改的ref对象<br>栗子</p><p><xmp><srcript><br>  <div></div><br></xmp></template><br><xmp><srcript><br>import { ref, reactive, computed } from “vue”;<br>export default {<br>  setup() {<br>    const num = ref(1);<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,<br>      num,<br>    });<br>    const num2 = computed(() =&gt; num.value + 1);<br>    return { num, obj, num2 };<br>  },<br>};<br></srcript><br></xmp></p><p>注意不可修改<br>如<br> const num2=computed(()=&gt;num.value+1)<br>    num2.value++</p><p>想要一个可以进行修改的，就需传一个具有get和set函数的对象<br><xmp><srcript><br>  <div></div><br></xmp></template><br><xmp><srcript><br>import { ref, reactive, computed } from “vue”;<br>export default {<br>  setup() {<br>    const num = ref(1);<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,<br>      num,<br>    });<br>    const num2 = computed({<br>        get:()=&gt;num,<br>        set:value=&gt;num.value=value<br>    });</p><pre><code>num2.value=3return &#123; num, obj, num2 &#125;;</code></pre><p>  },<br>};<br></srcript></xmp></p><p>要注意的是，此时num2这个ref对象不会在自动解套了<br>watch<br>监听一个<br><xmp><srcript><br>  <div></div><br></xmp></template><br><xmp><srcript><br>import { ref, reactive, computed, watch } from “vue”;<br>export default {<br>  setup() {<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,<br>      num,<br>    });</p><pre><code>watch(  () =&gt; obj.name,  (name, preName) =&gt; &#123;    console.log(`new $&#123;name&#125;---old $&#123;preName&#125;`);  &#125;);setTimeout(() =&gt; &#123;  obj.name = &quot;zhangsan&quot;;&#125;, 1000);return &#123; obj &#125;;</code></pre><p>  },<br>};<br></srcript></xmp></p><p>第一参除了可以是上面那种有返回值的getter函数，也可以是一个ref对象<br>即<br><xmp><srcript><br>  <div></div><br></xmp></template><br><xmp><srcript><br>import { ref, reactive, computed, watch } from “vue”;<br>export default {<br>  setup() {<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,<br>      num,<br>    });<br>    const num = ref(0);<br>    watch(num, (name, preName) =&gt; {<br>      console.log(<code>new $&#123;name&#125;---old $&#123;preName&#125;</code>);<br>    });<br>    setTimeout(() =&gt; {<br>      num.value = 2;<br>    }, 1000);</p><pre><code>return &#123; obj &#125;;</code></pre><p>  },<br>};<br></srcript></xmp></p><p>监听多个<br>即如下只要num或obj.name有一个发生变动就触发监听器处理回调<br><xmp><srcript><br>  <div></div><br></xmp></template><br><xmp><srcript><br>import { ref, reactive, computed, watch } from “vue”;<br>export default {<br>  setup() {<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,<br>      num,<br>    });<br>    const num = ref(0);<br>    watch([num, ()=&gt;obj.name], ([newNum, newName], [oldNum, oldName]) =&gt; {<br>      console.log(<code>new $&#123;(newNum)&#125;,$&#123;(newName)&#125;---old $&#123;(oldNum)&#125;,$&#123;oldName&#125;</code>);<br>    });<br>    setTimeout(() =&gt; {<br>      num.value = 6;<br>    //   obj.name = “zhangsan”;<br>    }, 1000);</p><pre><code>return &#123; obj &#125;;</code></pre><p>  },<br>};<br></srcript></xmp></p><p>生命周期钩子<br>栗子<br>import { onMounted, onUpdated, onUnmounted } from ‘vue’</p><p>const MyComponent = {<br>  setup() {<br>    onMounted(() =&gt; {<br>      console.log(‘mounted!’)<br>    })<br>    onUpdated(() =&gt; {<br>      console.log(‘updated!’)<br>    })<br>    onUnmounted(() =&gt; {<br>      console.log(‘unmounted!’)<br>    })<br>  },<br>}</p><p>对应2.x钩子</p><p>props和this<br>props<br>setup这个入口函数接收的第一个参数就是props<br>栗子</p><p>这里需要注意，不要随便进行解构<br>即图省事<br>  props: {<br>    data: String,<br>  },<br>  setup({ data }) {<br>    console.log(data);<br>  }</p><p>解构会使其丧失响应式的<br>this<br>2.x中拿组件实例实例很好拿，一般就是直接this，但是setup则不同。<br>但是组件实例上有许多api我们还是要使用的<br>故setup的第二个参数是一个上下文对象<br>栗子:派发一个自定义事件</p><p>值得注意的是这个context只是选择性的暴露了一些属性，如上面的emit还有attrs、slots<br>依赖注入与Refs<br>依赖注入<br>和vue2.x的provide和inject基本一样<br>栗子</p><p>为图简单我用的一个组件举例</p><p>它们的响应式需要自己出来一下（如用ref）<br>Refs<br>如拿下面这个节点</p><p><xmp><srcript><br>  <div ref="test">test</div><br></xmp></template><br><xmp><srcript><br>import {<br>  ref,<br>  reactive,<br>  computed,<br>  watch,<br>  provide,<br>  inject,<br>  onMounted,<br>} from “vue”;<br>export default {<br>  setup() {<br>    const test = ref(null);<br>    onMounted(() =&gt; {<br>      console.log(test.value);<br>    });</p><pre><code>return &#123; test &#125;;</code></pre><p>  },<br>};<br></srcript></xmp></p><p>一些工具函数<br>先来写下破坏reactive生成的响应对象代理的栗子<br>首先正常写法<br><xmp><srcript><br>  <div ref="test"><br>    <br>    &lt;button @click=”obj.age++”&gt;add</button><br>  </div><br></xmp></template><br><xmp><srcript><br>import { ref, reactive, computed, watch, provide, inject, readonly } from “vue”;<br>export default {<br>  props: {<br>    data: String,<br>  },<br>  setup(props, context) {<br>    console.log(props.data);<br>    context.emit(“test”);<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,</p><pre><code>&#125;);return &#123; obj &#125;;</code></pre><p>  },<br>};<br></srcript></xmp></p><p>使用扩展语法<br><xmp><srcript><br>  <div ref="test"><br>    <br>    &lt;button @click=”age++”&gt;add</button><br>  </div><br></xmp></template><br><xmp><srcript><br>import { ref, reactive, computed, watch, provide, inject, readonly } from “vue”;<br>export default {<br>  props: {<br>    data: String,<br>  },<br>  setup(props, context) {<br>    console.log(props.data);<br>    context.emit(“test”);<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,</p><pre><code>&#125;);return &#123; ...obj &#125;;</code></pre><p>  },<br>};<br></srcript></xmp></p><p>解构出来的同样不行<br><xmp><srcript><br>  <div ref="test"><br>    <br>    &lt;button @click=”age++”&gt;add</button><br>  </div><br></xmp></template><br><xmp><srcript><br>import { ref, reactive, computed, watch, provide, inject, readonly } from “vue”;<br>export default {<br>  props: {<br>    data: String,<br>  },<br>  setup(props, context) {<br>    console.log(props.data);<br>    context.emit(“test”);<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,<br>    });<br>    const { age } = obj;<br>    return { age };<br>  },<br>};<br></srcript></xmp></p><p>这个的原理也很简单，reactive的内部原理是Proxy，它操作均在返回的代理实例上<br>下面开始介绍几个工具函数</p><p>unref，参数是一个ref则返回这个ref的value属性，否则返本身<br>toRef，给一个 reactive 对象的属性创建一个 ref<br>toRefs， 把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref<br>isRef，判断一个值是否是ref<br>isProxy，判断一个对象是否是由 reactive 或者 readonly 方法创建的代理。<br>isReactive，判断一个对象是否是由 reactive 创建的响应式代理<br>isReadonly，判断一个对象是否是由 readonly 创建的只读代理。 </p><p>仅给2、3写个例子吧<br>toRef，即把reactive 对象上的一个属性变成ref<br>什么意思呢，还是看上面的破坏了响应式的栗子<br>修复一下(即可把它一个属性抽出来做成响应式的ref，且它们还是互相关联的)</p><p><xmp><srcript><br>  <div ref="test"><br>    <br>    &lt;button @click=”age++”&gt;add</button><br>  </div><br></xmp></template><br><xmp><srcript><br>import {<br>  ref,<br>  reactive,<br>  computed,<br>  watch,<br>  provide,<br>  inject,<br>  readonly,<br>  toRef,<br>} from “vue”;<br>export default {<br>  props: {<br>    data: String,<br>  },<br>  setup(props, context) {<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,<br>    });<br>    const age=toRef(obj, “age”);<br>    watch(()=&gt;obj.age,(newAge,oldAge)=&gt;{<br>        console.log(newAge);<br>    })<br>    return { age };<br>  },<br>};<br></srcript><br></xmp></p><p>toRefs则是把这个对象里面的所有属性均整成ref，这个修复则更简单了</p><p><xmp><srcript><br>  <div ref="test"><br>    <br>    &lt;button @click=”age++”&gt;add</button><br>  </div><br></xmp></template><br><xmp><srcript><br>import {<br>  ref,<br>  reactive,<br>  computed,<br>  watch,<br>  provide,<br>  inject,<br>  readonly,<br>  toRef,<br>  toRefs<br>} from “vue”;<br>export default {<br>  props: {<br>    data: String,<br>  },<br>  setup(props, context) {<br>    const obj = reactive({<br>      name: “gxb”,<br>      age: 18,<br>    });<br>    const obj02=toRefs(obj);</p><pre><code>return &#123; ...obj02 &#125;;</code></pre><p>  },<br>};<br></srcript></xmp></p><h2>1.2. Teleport</h2>传送门，顾名思义场景：某一些组件中我们可能需要一个模态框的功能，然而虽然逻辑上来说这个模态框是属于该组件中的，但是实际操作一般需要把这个框子挂到body上。Teleport 组件就是帮我们处理这个问题的来看栗子假设组件中需要有一个模态框<xmp><srcript>    <div>        <model></model>    </div></xmp></template><xmp><srcript>import Model from './model'export default {    components:{Model}}</srcript></xmp>模态框组件<p><xmp><srcript><br>  <div><br>    &lt;button @click=”flag=true”&gt;点击</button><br>    <teleport to="body"><br>      <div v-if="flag"><br>        <div>模态框</div><br>      </div><br>    </teleport><br>  </div><br></xmp></template><br><xmp><srcript><br>import { ref } from “vue”;<br>export default {<br>  setup() {<br>    const flag = ref(false);<br>    return { flag };<br>  },<br>};<br></srcript><br></xmp><br>即teleport组件的作用就是把teleport标签里面的元素传送到body上去</p><p>再看层级</p><h2>1.3. Fragments</h2>这个的理解就更简单了原来只能这样:即只允许存在一个最外层的父元素div<p><xmp><srcript><br>  <div><br>    …<br>  </div><br></xmp></template><br></xmp><br>现在可多个</p><p><xmp><srcript><br>  <div><br>    …<br>  </div><br>  <div><br>    …<br>  </div><br>    …<br></xmp></template><br></xmp></p><h2>1.4. Emits Component Option</h2><h3>1.4.1 自定义事件派发</h3>这里的重点：即多了一个派发事件的选项emits也就我们以后再次使用emit派发一个事件的时候需要把这此派发的事件名放到选项里栗子:<p><xmp><srcript><br>  <div><br>    &lt;button @click=”$emit(‘test’)”&gt;点击</button><br>  </div><br></xmp></template><br><xmp><srcript><br>export default {<br>  emits: [“test”],<br>};<br></srcript><br></xmp><br>注意：这里如果你派发的是一个原生事件，且没有把此事件放进emits选项中，其父组件的监听会被触发两次</p><p><xmp><srcript><br>  <div><br>    &lt;button @click=”$emit(‘click’)”&gt;点击</button><br>  </div><br></xmp></template><br><xmp><srcript><br>export default {<br>//   emits: [“click”],<br>};<br></srcript><br></xmp></p><h3>1.4.2 v-model</h3>vue3中的v-model,所借助的属性是 modelValue  所借助的事件是 update:modelValue (且3中把sync移出掉了)栗子父组件<p><xmp><srcript><br>  <div id="nav"><br>    <br>    <test05 v-model="data"></test05><br>  </div><br></xmp></template><br><xmp><srcript><br>import { ref } from “vue”;<br>import Test05 from “./components/test05”;<br>export default {<br>  components: { Test05 },<br>  setup() {<br>    const data=ref(‘gxb’)<br>    return {data};<br>  },<br>};<br></srcript><br></xmp><br>子组件</p><p><xmp><srcript><br>  <div><br>    &lt;input type=”text” :value=”modelValue” @input=”$emit(‘update:modelValue’,$event.target.value)” /&gt;<br>  </div><br></xmp></template><br><xmp><srcript><br>export default {<br>    props:{<br>        modelValue:String<br>    },<br>    emits:[‘update:modelValue’]<br>}<br></srcript></xmp></p><p>自定义属性名，vue2.x中可通过 model选项  指定传过来的属性名和指定本次v-model要利用的事件。 vue3中也可自定属性<br>栗子<br>父组件(即在v-model后面指定绑定)<br><test05 v-model:foo="data"></test05></p><p>子组件<br><xmp><srcript><br>  <div><br>    &lt;input type=”text” :value=”foo” @input=”$emit(‘update:foo’,$event.target.value)” /&gt;<br>  </div><br></xmp></template><br><xmp><srcript><br>export default {<br>    props:{<br>        foo:String<br>    },<br>    emits:[‘update:foo’]<br>}<br></srcript></xmp></p><p>一个组件中可写多个v-model指令<br>栗子：<br>父组件<br> <test01 v-model:foo="a" v-model:bar="b"></test01></p><p>子组件<br><xmp><srcript><br>  <div><br>    &lt;input type=”text” :value=”foo” @input=”$emit(‘update:foo’,$event.target.value)” /&gt;<br>    &lt;input type=”text” :value=”bar” @input=”$emit(‘update:bar’,$event.target.value)” /&gt;<br>  </div><br></xmp></template><br><xmp><srcript><br>export default {<br>  props: {<br>    foo: String,<br>    bar: String,<br>  },<br>  emits: [“update:foo”, “update:bar”],<br>  setup(props) {<br>    return {};<br>  },<br>};<br></srcript></xmp></p><h2>1.5. createRendererAPI</h2>自定义渲染器字如其名，它的主要功能是我们可以自定义 Virtual DOM 到DOM的方式，看了好3、4个大佬的栗子都是用canvas画了图。自己这里想不出什么栗子来先不写了二、其他2.1 Global API在vue2.x中没有应用的概念，vue2.x中的所谓的“app”也只不过是一个通过Vue构造出的实例。但是2.x中的一些全局API（像mixins、use、 component等 ）是直接在Vue构造函数中的也即如果下面还有使用new Vue的“应用”，这些全局API很容易造成污染下面来看一眼vue3的入口文件import { createApp } from 'vue'import App from './App.vue'import router from './router'import store from './store'<p>createApp(App).use(store).use(router).mount(‘#app’)</p><p>现在有了一个createApp，这个方法就返回一个应用程序的实例<br>拿component写个栗子<br>import { createApp, h } from ‘vue’<br>import App from ‘./App.vue’<br>import router from ‘./router’<br>import store from ‘./store’</p><p>createApp(App)<br>    .component(‘test06’, {<br>        render() {<br>            return h(‘div’, {}, ‘全局组件’)<br>        }<br>    })<br>    .use(store)<br>    .use(router)<br>    .mount(‘#app’)</p><p>其他API相应改变，如官网</p><p>Global API Treeshaking<br>官网是以 Vue.nextTick() ，这个全局API来举例的<br>这个摇树是什么玩意呢？</p><p>通过这句话可以理解，即这些个API不分青红皂白就写死在vue的构造函数上，如果我们在应用中本就没有对这些个API进行使用。那么打包时把这些东西也打进去是不是浪费性能同时也增大了打包体积呢<br>故vue3中，nextTick的使用也是需要从vue中导入一下的<br>import { nextTick } from ‘vue’</p><p>nextTick(() =&gt; {<br>  …<br>})</p><p>其他受影响的API</p><p>2.2 Template Directives<br>v-model<br>v-model上面已经写了，去掉了.sync，使用v-model进行了统一<br>v-if、v-for优先级问题<br>在2.x是v-for优先级高，在3.0中v-if的优先级高<br>2.3 Components<br>函数式组件<br>因为在vue3中函数式组件现在在性能上的提升可以忽略不计，还是推荐使用状态组件。<br>并且这里函数式组件只能通过纯函数进行声明，只能接受props和context（也是emit、slots、attrs）<br>简单搞个例子<br>这里偷个懒吧，把官网的栗子拿过来<br>vue2.x<br>// Vue 2 Functional Component Example<br>export default {<br>  functional: true,<br>  props: [‘level’],<br>  render(h, { props, data, children }) {<br>    return h(<code>h$&#123;props.level&#125;</code>, data, children)<br>  }<br>}</p><p>vue3,区别除了下面所要说的h函数变化问题，还有上面提到的参数问题，再一个变化就是去掉了 functional: true,<br>import { h } from ‘vue’</p><p>const DynamicHeading = (props, context) =&gt; {<br>  return h(<code>h$&#123;props.level&#125;</code>, context.attrs, context.slots)<br>}</p><p>DynamicHeading.props = [‘level’]</p><p>export default DynamicHeading</p><p>单文件形式对比<br>2.x<br>// Vue 2 Functional Component Example with <xmp><srcript><br><template functional><br>  <component    :is="`h${props.level}`"    v-bind="attrs"    v-on="listeners"  /><br></xmp></template></p><p><xmp><srcript><br>export default {<br>  props: [‘level’]<br>}<br></srcript></xmp></p><p>3.0,区别去掉了functional,监听器放进了$attrs且可删除<br><xmp><srcript><br>  <component    v-bind:is="`h${props.level}`"    v-bind="$attrs"  /><br></xmp></template></p><p><xmp><srcript><br>export default {<br>  props: [‘level’]<br>}<br></srcript></xmp></p><p>异步组件<br>原来异步组件咋整的呢<br>const asyncPage = () =&gt; import(‘./NextPage.vue’)</p><p>或者带选项的<br>const asyncPage = {<br>  component: () =&gt; import(‘./NextPage.vue’),<br>  delay: 200,<br>  timeout: 3000,<br>  error: ErrorComponent,<br>  loading: LoadingComponent<br>}</p><p>但是vue3中不一样了，这里有一个新的API defineAsyncComponent用来显示定义异步组件<br>也即<br>const asyncPage = defineAsyncComponent(() =&gt; import(‘./NextPage.vue’))</p><p>或<br>const asyncPageWithOptions = defineAsyncComponent({<br>  loader: () =&gt; import(‘./NextPage.vue’),<br>  delay: 200,<br>  timeout: 3000,<br>  errorComponent: ErrorComponent,<br>  loadingComponent: LoadingComponent<br>})</p><p>细心看也可看出component改成了loader<br>还有一点不同的是，2.x中函数参数中可接收resolve,reject,3.0则不可，但是必须要返回一个Promise</p><h2>2.4 Render Function</h2>渲染函数的改变即原来的h函数是这样的export default {  render(h) {    return h('div')  }}<p>而现在h函数则需要从vue的再导入进来<br>其实我上面有一个栗子已经用到了，再拿过来一次<br>import { createApp, h } from ‘vue’<br>import App from ‘./App.vue’<br>import router from ‘./router’<br>import store from ‘./store’</p><p>createApp(App)<br>    .component(‘test06’, {<br>        render() {<br>            return h(‘div’, {}, ‘全局组件’)<br>        }<br>    })<br>    .use(store)<br>    .use(router)<br>    .mount(‘#app’)</p><p>还有一个属性的变动，直接拿官网的栗子吧<br>2.x 中的节点属性格式<br>{<br>  class: [‘button’, ‘is-outlined’],<br>  style: { color: ‘#34495E’ },<br>  attrs: { id: ‘submit’ },<br>  domProps: { innerxmp: ‘’ },<br>  on: { click: submitForm },<br>  key: ‘submit-button’<br>}</p><p>在3.0中，这些属性不再被嵌套，被展平了(这看起来更像DOM节点上的东西了吧)<br>{<br>  class: [‘button’, ‘is-outlined’],<br>  style: { color: ‘#34495E’ },<br>  id: ‘submit’,<br>  innerxmp: ‘’,<br>  onClick: submitForm,<br>  key: ‘submit-button’<br>}</p><p>插槽方面<br>废掉了$scopedSlots，使用$slots<br>vue2.x中，一个组件使用渲染函数拿插槽是这样的</p><p><xmp><srcript><br>export default {<br>    render(h) {<br>        return h(‘div’,{},this.$scopedSlots.default)<br>    },<br>}<br></srcript><br></xmp><br>vue3.x中则是这样的<br></xmp><br><xmp><srcript><br>import {h} from ‘vue’<br>export default {<br>    props:{<br>        data:String<br>    },<br>    render() {<br>        return h(‘div’,{},this.$slots.default())<br>    },<br>}<br></srcript><br></xmp></p><h2>2.5 Custom Elements</h2>自定义元素白名单如一些特殊的组件，我们要特殊用处的希望vue的编译忽略栗子直接往组件中放一个为注册过的组件 <test08></test08><p>不希望出现这个错就把它放进白名单里<br>使用构建工具版本<br>rules: [<br>  {<br>    test: /.vue$/,<br>    use: ‘vue-loader’,<br>    options: {<br>      compilerOptions: {<br>        isCustomElement: tag =&gt; tag === ‘test08’<br>      }<br>    }<br>  }<br>  // …<br>]</p><p> 运行时编译版本<br>const app = Vue.createApp({})<br>app.config.isCustomElement = tag =&gt; tag === ‘test08’<br>is只能用在<component>上<br>但是 <component :is="componentId"></component> 除了这个玩意，我们别的地方可能也有需求需要用到is怎么办呢<br>故vue3中推出了v-is指令</p>]]></content>
    
    
    
    <tags>
      
      <tag>program</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊天室项目</title>
    <link href="/2020/09/19/%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/09/19/%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>github地址：<a href="https://github.com/genaller/genal-chat">https://github.com/genaller/genal-chat</a><br><img src="%E8%81%8A%E5%A4%A9%E5%AE%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>program</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first</title>
    <link href="/2020/09/18/first/"/>
    <url>/2020/09/18/first/</url>
    
    <content type="html"><![CDATA[<p>the first blog</p>]]></content>
    
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
